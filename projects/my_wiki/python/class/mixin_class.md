+++
title = 'Mixin_class'
date = 2024-01-18T22:06:32+02:00
draft = false
+++
**Mixin классы** - это классы у которых нет данных, но есть методы. Их называют ещё примесями. Mixin используются для добавления одних и тех же методов в разные классы.
В Python примеси делаются с помощью классов. Так как в Python нет отдельного типа для примесей, классам-примесям принято давать имена заканчивающиеся на **Mixin**.
С одной стороны, то же самое можно сделать с помощью наследования обычных классов, но не всегда те методы, которые нужны в разных дочерних классах, имеют смысл в родительском. Как и не всегда есть доступ к редактированию родительского класса.
Рассмотрим пример:
```python
class Shape:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def serialized(self):
        print (",".join([f"{k}={v}" for k, v in self.__dict__.items()]))
class Rectangle(Shape):
    def __init__(self, x, y, width, height):
        super().__init__(x, y)
        self.width = width
        self.height = height
class Circle(Shape):
    def __init__(self, x, y, radius):
        super().__init__(x, y)
        self.radius = radius
```
В примере определены два класса, `Rectangle` и `Circle`, которые наследуются от базового класса `Shape`. Разберемся с каждым из них:
* **Shape (Форма/Определения):**
Это базовый класс, который имеет конструктор `__init__`, принимающий координаты x и y и устанавливающий их как атрибуты объекта.
метод `serialized` выводит сериализованное представление атрибутов объекта, преобразованных в строку в формате `"ключ"="значение"`.
* **Rectangle (Прямоугольник):**
Этот класс наследуется от Shape. Он добавляет два дополнительных атрибута, `width` (ширина) и `height` (высота), которые также инициализируются в конструкторе.
Конструктор вызывает конструктор базового класса Shape с использованием `super().__init__(x, y)` для установки координат x и y.
* **Circle (Круг):**
Этот класс также наследуется от `Shape`. Он добавляет один дополнительный атрибут, `radius` (радиус), и инициализирует его в конструкторе.
Конструктор вызывает конструктор базового класса `Shape` с использованием `super().__init__(x, y)` для установки координат `x` и `y`.
```python
r = Rectangle(0, 0, 100, 50)
c = Circle (0, 0, 50)
r.serialized() #x=0,y=0,width=100,height=50
c.serialized() #x=0,y=0,radius=50
```
Этот код создает экземпляры `Rectangle` и `Circle`, и для каждого из них вызывается метод `serialized`, который выводит сериализованное представление их атрибутов.
Всё хорошо работает, но, представим, что у нас в родительском классе, много лишних методов или атрибутов, которые будут дубдироваться при вызове нагружая систему, или он закрыт от редактирования и мы не можем в него добавить метод `serialized`... На помощь нам приходят миксины! рассмотрим код ниже:
```python
class Shape:
    def __init__(self, x, y):
        self.x = x
        self.y = y
class SerializedMixIn: #This MixIn
    def serialized(self):
        print (",".join([f"{k}={v}" for k, v in self.__dict__.items()]))
class Rectangle(Shape, SerializedMixIn):
    def __init__(self, x, y, width, height):
        super().__init__(x, y)
        self.width = width
        self.height = height
class Circle(Shape, SerializedMixIn):
    def __init__(self, x, y, radius):
        super().__init__(x, y)
        self.radius = radius
r = Rectangle(0, 0, 100, 50)
c = Circle (0, 0, 50)
r.serialized() #x=0,y=0,width=100,height=50
c.serialized() #x=0,y=0,radius=50
```
Теперь в вашем коде используется миксин `SerializedMixIn`, который предоставляет метод `serialized` для сериализации атрибутов объекта. Оба класса, `Rectangle` и `Circle`, используют этот миксин для обеспечения сериализации своих атрибутов.
Давайте разберемся с кодом:
* **Shape:**
Этот класс так же просто содержит атрибуты x и y и их инициализацию в конструкторе.
* **SerializedMixIn:**
Этот миксин предоставляет метод `serialized`, который выводит атрибуты объекта в виде строки.
Напомним, что Миксин, не имеет собственного конструктора, а его цель - предоставить дополнительную функциональность для других классов.
* **Rectangle и Circle:**
Оба класса наследуются от `Shape` и `SerializedMixIn`.
Они имеют собственные конструкторы, где они вызывают конструктор базового класса `Shape` и инициализируют дополнительные атрибуты (width и height для Rectangle, radius для Circle).
Таким образом, объекты классов `Rectangle` и `Circle` имеют атрибуты x и y от `Shape` и метод `serialized` от миксина `SerializedMixIn`.
>Пояснения для метода **serialized**: `print (",".join([f"{k}={v}" for k, v in self.__dict__.items()]))`
>* Конструкция `",".join([f"{k}={v}" for k, v in self.__dict__.items()])` используется для создания строки, в которой перечислены пары "ключ=значение" для всех атрибутов объекта. Давайте разберемся, как это работает:
>* `self.__dict__.items()`: Этот код возвращает представление атрибутов объекта в виде словаря. `self.__dict__` содержит все атрибуты объекта, и `items()` возвращает пары "ключ-значение" в виде кортежей.
>* `[f"{k}={v}" for k, v in self.__dict__.items()]`: Это генератор списка, который создает строковые представления для каждой пары "ключ=значение". Здесь k - ключ (имя атрибута), v - значение атрибута. Каждая строка в списке будет выглядеть как "ключ=значение".
>* `",".join(...)`: Этот метод строки `(join())` объединяет все элементы списка (строки "ключ=значение") в одну строку, разделяя их запятой. Таким образом, получится строка вида "ключ1=значение1,ключ2=значение2,...".