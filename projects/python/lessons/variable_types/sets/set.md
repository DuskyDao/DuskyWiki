+++
title = 'Set'
date = 2024-02-20T19:45:53+02:00
draft = false
+++
**Содержание:**
1. **[Создание множества:](#создание-множества)**
2. **[Добавление элемента:](#добавление-элемента)**
3. **[Удаление элемента:](#удаление-элемента)**
4. **[Операции над множествами:](#операции-над-множествами)**
5. **[Проверка на принадлежность:](#проверка-на-принадлежность)**
6. **[Длина множества:](#длина-множества)**
7. **[Итерирование по множеству:](#итерирование-по-множеству)**
8. **[Копирование множества:](#копирование-множества)**
9. **[Подмножества и надмножества:](#подмножества-и-надмножества)**
10. **[Проверка - разные ли множества:](#проверка---разные-ли-множества)**
11. **[Вывод](#вывод)**  

Тип данных **set** в Python представляет собой неупорядоченную коллекцию уникальных элементов. Это означает, что каждый элемент в множестве уникален (не может повторяться), и порядок элементов не сохраняется. Множества в Python реализованы на основе хэш-таблиц, что делает операции добавления, удаления и проверки на принадлежность элементу очень эффективными.  

**Вот основные методы и операции, которые можно выполнять с объектами типа set:**  
##### Создание множества:
```python
my_set = {1, 2, 3}  # Литеральная нотация
my_set = set([1, 2, 3])  # Из списка

my_set = [1,1,1,1,3,3,3,3,2,2,2,5,5,7,7,7,5,5,4,4,4]
my_set = set(sorted(my_set)) # переводим список в множество и сортируем
print (my_set) # {1, 2, 3, 4, 5, 7}
```
##### Добавление элемента:
```python
my_set.add(4)
```
##### Удаление элемента:
```python
my_set.remove(2)  # Если элемент не найден, вызывает ошибку
my_set.discard(5)  # Удаляет элемент, если он есть, без ошибки
my_set.pop()  # Удаляет и возвращает произвольный элемент, если множество не пусто
my_set.clear()  # Очищает множество
```
##### Операции над множествами:
```python
set1 = {1, 2, 3}
set2 = {3, 4, 5}

set3 = set1.union(set2)  # обьединяем множества
union_set = set1 | set2  # Объединение множеств

print (set1.update(set2)) # обновляет set1 данными с set2 без создания нового сета как с методом "union". Так же работают все апдейты

print (my_set1.intersection(my_set2))  # ищет пересечения в множестве
intersection_set = set1 & set2  # Пересечение множеств

print (my_set1.difference(my_set2))  # выводит отличия первого сета от 2го
difference_set = set1 - set2  # Разность множеств (все элементы, которые есть в set1, но отсутствуют в set2)

print (my_set1.symmetric_difference(my_set2))  # выводит отличия 1го от 2го и 2го и 1го по порядку
symmetric_difference_set = set1 ^ set2  # Симметрическая разность множеств (все элементы, которые есть только в одном из множеств)
```
##### Проверка на принадлежность:
```python
if 2 in my_set:
    print("2 есть в множестве")

print (44 in my_set) # False посмотреть есть ли переменная в множестве
```
##### Длина множества:
```python
len(my_set)
```
##### Итерирование по множеству:
```python
for item in my_set:
    print(item)
```
##### Копирование множества:
```python
new_set = my_set.copy()
```
##### Подмножества и надмножества:
```python
is_subset = subset_set.issubset(super_set)  # Проверка, является ли subset_set подмножеством super_set
is_superset = super_set.issuperset(subset_set)  # Проверка, является ли super_set надмножеством subset_set

#пример
my_set = {1, 2, 3, 4, 5, 7}
my_set2 = {1, 2, 3, 4, 5, 7, 8}
print (f" 1 с 2м {my_set.issubset(my_set2)}") # True проверяет вхождение элементов множества в последовательности, ли my_set - my_set2
print (f" 2й с 1м {my_set2.issubset(my_set)}") # False проверяет принадлежит ли my_set2 - my_set 
res = my_set <= my_set2 # короткая запись

print (f" 1й с 2м {my_set.issuperset(my_set2)}")  # роверяет вхождение элементов последовательности в множества. В параметре указываем последовательность, с которой хотим сравнить элементы множества. 
res = my_set >= my_set2 # короткая запись
```
##### Проверка - разные ли множества
```python
s= {1,2,3}
d= {4,5,6}
print (s.isdisjoint(d)) #True проверяет на разность елементов в множествах (тру - разные)
```
##### Вывод:
Методы множества в Python предоставляют мощные возможности для работы с уникальными наборами данных и множественными операциями. Они широко используются в различных сценариях, таких как удаление дубликатов, проверка наличия элементов и многое другое.