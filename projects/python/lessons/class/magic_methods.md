+++
title = 'Magic_methods'
date = 2024-01-20T22:43:58+02:00
draft = false
+++
Магические методы в Python представляют собой специальные методы, начинающиеся и заканчивающиеся двумя подчеркиваниями (например, `__init__`, `__str__`). Эти методы предназначены для переопределения в классах, чтобы изменить или определить специфичное поведение объектов в рамках различных операций и функциональности.\
Вот несколько часто используемых магических методов:
* **__init__(self, ...)**: Метод инициализации, вызывается при создании нового объекта. Он используется для инициализации атрибутов объекта.
* **__str__(self)**: Метод, вызываемый функцией `str()` или при использовании встроенной функции `print()`. Позволяет определить строковое представление объекта.
* **__repr__(self)**: Метод, вызываемый функцией `repr()`. Предоставляет "формальное" строковое представление объекта, которое может быть использовано для воссоздания объекта.
* **__len__(self)**: Метод, вызываемый функцией `len()`. Позволяет определить длину объекта.
* **__add__(self, other)**: Метод, вызываемый при использовании оператора +. Позволяет определить, как объекты должны быть сложены.
* **__sub__(self, other)**: Метод, вызываемый при использовании оператора -. Позволяет определить, как объекты должны быть вычтены.
* **__eq__(self, other)**: Метод, вызываемый при использовании оператора ==. Позволяет определить, когда два объекта считаются равными.
* **__lt__(self, other)**: Метод, вызываемый при использовании оператора <. Позволяет определить, когда один объект меньше другого.
* **__call__(self, ...)**: Метод, вызываемый при вызове экземпляра класса как функции. Позволяет классу имитировать функциональность.
* **__getitem__(self, key)**: Метод, вызываемый при обращении к элементу по индексу, например, `obj[key]`.
* **__dict__**: посмотреть все атрибуты класса или екземпляра
*  **__subclasses__**: посмотреть подкласс екземпляра или класса
*  **__name__**: имя функции

Это всего лишь небольшой набор магических методов. Однако их существует множество, и они предоставляют возможность настраивать различные аспекты поведения объектов в Python. Реализация или переопределение этих методов в классе позволяет объектам вести себя определенным образом при использовании различных операторов или функций.\
Более подробая [статья на Хаюре](https://habr.com/ru/articles/186608/)

### Пример сравнения и сумирования для методов:  
которые либо не доступны, либо не правильно работают, так как интерпретатор питона не знает, что делать с данными аргументами и методами классов:
```python
class Comment:
    def __init__(self, text):
        self.text = text
        self.votes_qty = 0
    
    def upvote(self):
        self.votes_qty +=1
        
    def __add__(self, other):  # прописываем поведения для магического метода сумирования
        return {'text': f"{self.text} {other.text}", 'total_votes_qty': self.votes_qty + other.votes_qty}
    
    def __eq__(self, other):  # прописываем поведения для магического метода сравнения
        return (self.text == other.text and self.votes_qty == other.votes_qty)
                
dd = Comment("Bibochka")
dd.upvote()
bb = Comment("Biba")
bb.upvote()
print (dd + bb)  # {'text': 'Bibochka Biba', 'total_votes_qty': 2}
print (dd == bb)  # False
```
