+++
title = 'Static Methods'
date = 2024-01-16T15:44:49+02:00
draft = false
+++
### **Статические методы** 
Концепции **@classmethod** и **@staticmethod** в Python связаны с определением методов внутри классов, но их использование и поведение отличаются:
#### @classmethod:
1. **Принимает ссылку на класс:**
   * Метод, помеченный @classmethod, принимает первым параметром ссылку на класс (часто именуемую cls).
   * Это позволяет методу взаимодействовать с атрибутами класса.
2. **Обращение к атрибутам класса:**
   * Метод может использоваться для работы с атрибутами класса или вызова других методов класса.
   * Поскольку метод имеет доступ к классу, он может использовать классные атрибуты.
3. **Используется для создания альтернативных конструкторов:**
   * Часто используется для создания альтернативных конструкторов, которые позволяют создавать экземпляры класса с использованием различных параметров.
Пример:
```python
class MyClass:
    class_variable = "I am a class variable"

    @classmethod
    def class_method(cls):
        print(cls.class_variable)

# Вызов метода класса без создания экземпляра
MyClass.class_method()
```
#### **@staticmethod:**
1. **Не принимает ссылку на класс:**
    * Метод, помеченный @staticmethod, не принимает ссылку на класс (или экземпляр) в качестве первого параметра.
    * Не имеет доступа к атрибутам класса.
2. **Независим от класса и экземпляра:**
    * Не обладает ссылкой на класс или экземпляр, и, таким образом, не имеет доступа к их атрибутам.
3. **Простая функция внутри класса:**
    * Метод является просто функцией, которая находится в пространстве имен класса.
Пример:
```python
class MyClass:
    @staticmethod
    def static_method():
        print("I am a static method")

# Вызов статического метода без создания экземпляра
MyClass.static_method()
```
#### Когда использовать каждый из них:
**@classmethod:**
   * Используйте, когда методу нужен доступ к атрибутам класса.
   * Хорошо подходит для создания альтернативных конструкторов.


**@staticmethod:**
   * Используйте, когда метод не зависит от атрибутов класса и не требует ссылки на класс или экземпляр.
   * Хорошо подходит для группировки функциональности, которая связана с классом, но не требует его состояния.
Выбор между @classmethod и @staticmethod зависит от того, требуется ли вашему методу доступ к классовым атрибутам и поведению.

### Пример №1
взято с [timeweb.cloud](https://timeweb.cloud/tutorials/python/staticheskij-metod-python)\

[//]: # (Это комментарий, он не будет отображаться)

Представим, что у нас есть класс MathUtils, который содержит статический метод для вычисления факториала:
```python
class MathUtils:
    @staticmethod
    def factorial(n):
        if n == 0:
            return 1
        else:
            return n * MathUtils.factorial(n-1)
print(MathUtils.factorial(5))
#120
```
Получили факториал 5, то есть 120. Здесь статический метод factorial не использует никакие атрибуты экземпляра класса, а только входной аргумент n. И мы вызвали его, используя синтаксис MathUtils.factorial(n) и не создавая экземпляр класса MathUtils.

Далее отметим, что статические методы в Python могут использоваться не только в классах, но также в модулях и пакетах. Если вы определяете функцию в модуле и не хотите, чтобы она была связана с экземпляром класса или модулем, вы можете использовать декоратор @staticmethod для объявления этой функции как статической.
### Пример №2
Допустим, у нас есть модуль StringUtils, содержащий статический метод для проверки, является ли строка палиндромом. Пишем такой код:
```python
def is_palindrome(string):
    return string == string[::-1]
```
*Здесь функция is_palindrome не связана с каким-либо экземпляром класса или объектом модуля, поэтому мы можем использовать декоратор @staticmethod для объявления ее как статической. Для этого расширим наш код таким образом:*  
```python
class StringUtils:
    @staticmethod
    def is_palindrome(string):
        return string == string[::-1]
#Далее введем для проверки:
print(StringUtils.is_palindrome("топот"))
#True
print(StringUtils.is_palindrome("топор"))
#False
```
Всё верно, первое слово является палиндромом, поэтому интерпретатор вывел True, а второе нет, и мы получили False.

Таким образом, мы можем вызвать метод is_palindrome через класс StringUtils, используя синтаксис StringUtils.is_palindrome(string) вместо того, чтобы импортировать функцию is_palindrome и вызывать ее напрямую.

Еще одно важное отличие статических методов от методов экземпляров класса в Python заключается в том, что статические методы не могут изменять состояние экземпляра. Это означает, что они не могут изменять значения атрибутов, что логично, так как они не имеют доступа к экземпляру. Если вы хотите изменить состояние экземпляра класса, вам нужно использовать методы экземпляров.
### Пример №3
Рассмотрим еще один пример. Допустим, у нас есть класс Person, имеющий атрибут age и статический метод is_adult, проверяющий значение на соответствие возрасту совершеннолетия:
```python
class Person:
    def __init__(self, age):
        self.age = age

    @staticmethod
    def is_adult(age):
        return age >= 18
```
Далее давайте создадим переменную age со значением 21, вызовем статический метод is_adult из класса Person с этим значением и сохраним его результат в переменную is_adult, вот так:
```python    
age = 21
is_adult = Person.is_adult(age)

#Теперь для проверки давайте введем:
print(is_adult)
#True
```
Поскольку возраст соответствует заданному в статическом методе условию, мы получили True. В примере выше статический метод is_adult принимает аргумент age, но не имеет доступа к атрибуту age экземпляра класса Person, выступая в качестве вспомогательной функции.
Напишем простой класс который будет выводить дату, месяц и год
### Пример 4
Создадим класс Date с 3мя аргументами. Протестируем вывод с него двумя способами
```python
class Date():
    def __init__(self, date, mount, year):
        self.date = date
        self.mount = mount
        self.year = year
    def method(self):
        return f'{self.date} {self.mount} {self.year} года'
ee = Date(11, 'april', 1983)
print (ee.method()) 
print (Date(11, 'april', 1983).method()) # либо так
# 11 april 1983 года
# 11 april 1983 года
```
Добавим к классу 2 декоратора для понимания разници **@classmethod** и **@staticmethod**
```python
class Date():
    def __init__(self, day, month, year):
        self.day = day
        self.month = month
        self.year = year
    def method(self):
        return f'{self.day} {self.month} {self.year} года'
    @classmethod
    def millenium_c(cls, day, month):
        return cls(day, month, 2000)
    @staticmethod
    def millenium_s(day, month):
        return Date(day, month, 2000)

ccc = Date.millenium_c(11, 'april')
sss = Date.millenium_s(11, 'april')
print (ccc.method()) 
print (sss.method())
# 11 april 2000 года
# 11 april 2000 года
```
Как мы видим  вывод в данном случае одинаковый
### Подведем итоги
В завершение отметим, что статические методы улучшают читабельность кода и дают возможность повторно использовать его. А еще они удобнее, если сравнивать их со стандартными функциями Python. Удобство статических методов в том, что они не требуют отдельного импорта, как это нужно делать для функций. Таким образом, использование статических методов класса Python может существенно упростить код и работу с ним. И, как вы наверняка убедились на примерах выше, освоить их довольно просто.