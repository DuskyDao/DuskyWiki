+++
title = 'Default_function'
date = 2024-02-14T21:31:23+02:00
draft = false
+++
### Квадрат числа
```python
import function
for i in range(10):
    print (f"zalupa {i} ravna {function.square(i)}")
```

```python
abs(-1) # 1 всегда делает число положительным
```
# Взятие числа по модулю
```python
max(1,2,4,65,7) # 65 макс число
min([2,4,5,1,2,5]) # 1 мин число, можно передавать и список
```
```python
pow(2,8) # 256 - 2 в 8
```
# возвести в степень
### Округление числа
```python
round(3.124, 2) # 3.12
```
### suma
```python
sum([1,2,3,4,5]) #15
```

```python
a = hex(42) # 0x2a шестнадцетиричный
b = oct(42) # 0o52 восмиричный
c = bin(42) # 0b101010 двочный```
#форматы 2чный, 8миричный и 16ричный
```
```python
aa = all([True, True, True]) #True 
bb = all([True, False, True]) #False
rr = [('Karlo', 2400), ('Mona', 2600), ('Dora', 2555), ('Jack', 2222)]
rrr = all(rating > 2400 for _, rating in rr) # False проверяем список с кортежами на наличие рейтинга віше 2400. Конструкция _, rating перебору содержимого в кортеже, первое значение упускается)```
# булевые функции all - проверяет является ли True ВСЕ переменные в листе или кортеже
```
```python
aa = any([False, True, False]) #True 
bb = all([False, False, False]) #False
ttt = any(rating == 2555 for _, rating in rr) # True```
# any если хотя бы 1н Тру то выводит Тру
```
```python
eee = 'zalupa'
rrrd = (3,2,4,1)
zip_test = zip(eee, rrrd)
print (type(zip_test)) # <class 'zip'> особый класс
print (zip_test) # <zip object at 0x000001F16E9A88C0>  просто показівает в какую ячейку памяти отработала функция
zip_test2 = list(zip_test)
print (zip_test2) # [('z', 3), ('a', 2), ('l', 4), ('u', 1)] ```
# zip функция для склеивания списков или текста, част оиспользуется для создания словарей
```
```python
ere = ord('6')
print (ere) #54```
# ord вывод значения символа в уникоде
```
```python
ere2 = chr(54)
print (ere2) # 6```
# chr вывод символа с юникода
```
### Функция filter
**filter()** - это встроенная функция в Python, которая позволяет фильтровать элементы последовательности (например, списки, кортежи и т. д.) с помощью функции, возвращающей логическое значение True или False.

Синтаксис функции filter() выглядит следующим образом:
```python
filter(function, iterable)
```
* **function** - это функция, которая принимает один аргумент и возвращает логическое значение (True или False). Эта функция применяется к каждому элементу iterable.
* **iterable** - это последовательность, которую вы хотите отфильтровать.
* **filter()** возвращает итератор, который содержит те элементы из iterable, для которых функция function возвращает True.

Пример использования filter():
```python
# Функция, которая возвращает True для нечетных чисел
def is_odd(x):
    return x % 2 != 0

# Исходный список
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Фильтрация списка с использованием функции is_odd
filtered_numbers = filter(is_odd, numbers)

# Преобразование результата в список (для удобства просмотра)
filtered_numbers = list(filtered_numbers)

print(filtered_numbers)  # Выводит: [1, 3, 5, 7, 9]
```
Здесь **filter(is_odd, numbers)** фильтрует элементы списка numbers, применяя функцию is_odd к каждому элементу. Возвращается итератор, содержащий только те элементы, для которых is_odd вернула True. После этого результат преобразуется в список с помощью list(filtered_numbers).

Функция `filter()` может быть очень удобной для фильтрации данных в Python и часто используется вместе с анонимными функциями (lambda), чтобы сделать код более компактным.  
**Ещё пример:**
```python
def filtering(list_f, type_l):
    def filter_f(list_true):
        return type(list_true) is type_l
    return list(filter(filter_f, list_f))
print (filtering([33, True, [1, 3], 'abc', {'ff': 'rr', 'ttt': 55}, 44, 43.555, 'def'], int))  #  [33, 44]

# с лямбдой
def filtering(list_f, type_l):
    return list(filter((lambda list_true: type(list_true) is type_l), list_f))
print (filtering([33, True, [1, 3], 'abc', {'ff': 'rr', 'ttt': 55}, 44, 43.555, 'def'], int))  #  [[1, 3]]
```
### **Функция enumerate**
Функция **enumerate()** в Python является встроенной функцией, которая предоставляет удобный способ итерации по элементам последовательности (например, списка, кортежа или строки) одновременно с их индексами. Она возвращает объект-перечисление (enumerator), который генерирует последовательность кортежей, содержащих индекс элемента и сам элемент.

Синтаксис функции `enumerate()` выглядит следующим образом:
```python
enumerate(iterable, start=0)
```
* **iterable** - последовательность, для которой вы хотите получить индексы и элементы.
* **start** (необязательный параметр) - начальное значение индекса. По умолчанию start равен 0.
* **enumerate()** возвращает итератор, который генерирует кортежи вида (индекс, элемент), где индекс - это порядковый номер элемента в последовательности, а элемент - сам элемент из iterable.

**Пример использования enumerate():**
```python
# Исходный список
my_list = ['apple', 'banana', 'cherry', 'date']

# Итерация по списку с использованием enumerate()
for index, value in enumerate(my_list):
    print(f"Index: {index}, Value: {value}")
# Index: 0, Value: apple
# Index: 1, Value: banana
# Index: 2, Value: cherry
# Index: 3, Value: date
```
В этом примере `enumerate(my_list)` создает итератор, который генерирует кортежи (индекс, элемент) для каждого элемента в `my_list`. При итерации по этому итератору переменные `index` и `value` принимают значения индекса и соответствующего элемента.

Функция `enumerate()` часто используется в циклах `for`, когда вам нужно не только получить доступ к элементам последовательности, но и знать их индексы. Она удобна и эффективна, особенно когда вам нужно обрабатывать элементы и их индексы одновременно.  
**Ещё простой пример:**
```python
gg = [1,2,3,4,5]
print ({k: v for k, v in enumerate(gg)})  # {0: 1, 1: 2, 2: 3, 3: 4, 4: 5}
```